package fr.uha.hassenforder.logo.reader;

parser import code {:
import java.util.List;
import fr.uha.hassenforder.logo.interpreter.LogoContext;
import fr.uha.hassenforder.logo.factory.LogoFactory;
import fr.uha.hassenforder.ast.Node;
import fr.uha.hassenforder.ast.Symbol;
import fr.uha.hassenforder.ast.SymbolFunction;
:}

parser code {:

    public void report_error(String message, Object info) {
        StringBuffer m = new StringBuffer("Error");
		m.append (info.toString());
        m.append(" : "+message);
        System.err.println(m.toString());
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    
	private LogoContext context;
    public void setContext (LogoContext context) {
    	this.context = context;
    }

    public LogoContext getContext () {
		return context;
    }

	public LogoFactory getFactory () {
		return getContext().getFactory();
	}

:}

scanner code {:
    private Symbol fallback () {
    	return symbol(ETerminal.OOA);
	}    
:}

terminal 				UNARIES;
terminal Double			NUMBER;
terminal String			ID, TEXT, PARAM;

nonterminal 			command, definition;
nonterminal Symbol			declaration;
nonterminal SymbolFunction	functionSignature;
nonterminal					functionParamsOpt, functionParams, functionParam;
nonterminal Node    		functionBody;
nonterminal List<Node>	bloc, params;
nonterminal Node		instruction;
nonterminal Node		expr, exprOpt, param;

precedence left		'+', '-';
precedence left		'*', '/';
precedence right	UNARIES;

start with command;

command		::= definition *
			;

definition ::=	declaration:decl				{: parser.getContext().addLocalSymbol (decl); :}
			| 	instruction:inst ';'			{: parser.getContext().addGlobalInstruction(inst); :}
			;

declaration	::= functionSignature:function functionBody:body
					{:
						function.setCode (body);
						RESULT = function;
					:}
			;

functionSignature ::= 'function' ID:name 
					{:
						SymbolFunction function = parser.getFactory().createSymbolFunction(name);
						function.setTable(parser.getFactory().createSymbolTable (name));
						parser.getContext().getVista().push (function.getTable());
						RESULT = function;
					:}
					functionParamsOpt
				;

functionParamsOpt	::=	'(' functionParams ? ')'
					;

functionParams		::=	functionParam ( ',' functionParam )*
					;

functionParam		::=	ID:name {: parser.getContext().addLocalSymbol (name); :}
					;

functionBody	::=	'{' bloc:code '}'
					{:
						parser.getContext().getVista().pop ();
						RESULT = parser.getFactory().createNodeBloc (code);
					:}
			;

instruction ::=								{: RESULT = null; :}
			| 'frame' expr:x ',' expr:y		{: RESULT = parser.getFactory().createTurtleFrame   (x, y); :}
			| 'home'						{: RESULT = parser.getFactory().createTurtleHome    (); :}
			| 'up' exprOpt:p				{: RESULT = parser.getFactory().createTurtleUp      (p); :}
			| 'down' exprOpt:p				{: RESULT = parser.getFactory().createTurtleDown    (p); :}
			| 'right' exprOpt:p				{: RESULT = parser.getFactory().createTurtleRight   (p); :}
			| 'left' exprOpt:p				{: RESULT = parser.getFactory().createTurtleLeft    (p); :}
			| 'pen' 'off'					{: RESULT = parser.getFactory().createTurtleOff	(); :}
			| 'pen' 'on'					{: RESULT = parser.getFactory().createTurtleOn (); :}
			| 'goto' expr:x ',' expr:y		{: RESULT = parser.getFactory().createTurtleGo      (x,y); :}
			| 'move' exprOpt:d				{: RESULT = parser.getFactory().createTurtleMove    (d); :}
			| 'turn' expr:a					{: RESULT = parser.getFactory().createTurtleTurn	(a); :}
			| 'plot' expr:t					{: RESULT = parser.getFactory().createTurtlePlot	(t); :}
			| 'ink' expr:i					{: RESULT = parser.getFactory().createTurtleInk	(i); :}
			| ID:id '=' expr:v				{: RESULT = parser.getFactory().createTurtleSet (id, v); :}
			| '{' bloc:b '}'				{: RESULT = parser.getFactory().createNodeBloc (b); :}
			| 'repeat' expr:count 'times' instruction:inst
											{: RESULT = parser.getFactory().createTurtleLoop (count, inst); :}
			| ID:id params?:p				{: RESULT = parser.getFactory().createTurtleCall (id, p); :}
//			| ID:id '(' params?:p ')'		{: RESULT = parser.getFactory().createTurtleCall (id, p); :}
			;

bloc		::=	( instruction:inst ';' {: RESULT = inst; :} ) *
			;
			
exprOpt 	::=							{: RESULT = parser.getFactory().createNodeConstantReal (1.0); :}
			| expr:v					{: RESULT = v; :}
			;

expr		::=	'(' expr:e ')'			{: RESULT = e; :}
			| expr:e1 '+' expr:e2		{: RESULT = parser.getFactory().createNodeAdd (e1, e2); :}
			| expr:e1 '-' expr:e2		{: RESULT = parser.getFactory().createNodeSub (e1, e2); :}
			| expr:e1 '*' expr:e2		{: RESULT = parser.getFactory().createNodeMult (e1, e2); :}
			| expr:e1 '/' expr:e2		{: RESULT = parser.getFactory().createNodeDiv (e1, e2); :}
			| '+' expr:e				{: RESULT = parser.getFactory().createNodePlus(e); :} %prec UNARIES
			| '-' expr:e				{: RESULT = parser.getFactory().createNodeMinus(e); :} %prec UNARIES
			| NUMBER:n					{: RESULT = parser.getFactory().createNodeConstantReal (n.doubleValue());; :}
			| ID:id						{: RESULT = parser.getFactory().createNodeVariable (id); :}
			| TEXT:v					{: RESULT = parser.getFactory().createNodeConstantString (v); :}
			| PARAM:id					{: RESULT = parser.getFactory().createNodeVariable (id); :}
			;

params	::=	param:first	( ',' param:p {: RESULT = p; :} ) *:list
										{:
											list.add(0, first);
											RESULT = list;
										:}
		;

param	::=	expr:e						{: RESULT = e; :}
		;
		
terminal void SPACES, COMMENT;

COMMENT		::=	`#.*`
			|	'/*' ~ '*/'
			;

SPACES		::=	`[ \t\f\r\n]+`
			;

NUMBER		::=	`[0-9]+("."[0-9]+)?[eE][+-]?[0-9]+`
			|	`[0-9]*"."[0-9]+([eE][+-]?[0-9]+)?`
			|	`[0-9]+`
			;
		
ID			::=	`[A-Za-z_][A-Za-z_0-9]*`
			;

PARAM		::=	`\$[1-9]`
			;

TEXT		::=	`\"[^\"]*\"`			{: return symbol (ETerminal.TEXT, new String( zzBuffer, zzStartRead+1, zzMarkedPos-zzStartRead-2 )); :}
			;
